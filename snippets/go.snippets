snippet v "shorthand variable declaration"
	${1} := ${2}

snippet vr "variable initialization"
	var ${1:t} ${0:string}

snippet var "variable declaration"
	var ${1} ${2} = ${3}

snippet vars "variables declaration"
	var (
		${1} ${2} = ${3}
	)

snippet ap "append"
	append(${1:slice}, ${0:value})

snippet bl "bool"
	bool

snippet bt "byte"
	byte

snippet br "break"
	break

snippet ch "channel"
	chan ${0:int}

snippet cs "case"
	case ${1:value}:
		${0:${VISUAL}}

snippet co "constants with iota"
	const (
		${1:NAME1} = iota
		${0:NAME2}
	)

snippet cn "continue"
	continue

snippet df "defer"
	defer ${0:func}()

snippet dfr "defer recover"
	defer func() {
		if err := recover(); err != nil {
			${0:${VISUAL}}
		}
	}()

snippet im "import"
	import (
		"${1:package}"
	)

snippet in "interface"
	interface{}

snippet inf "full interface "
	interface ${1:name} {
		${2:/* methods */}
	}

snippet if "if condition"
	if ${1:/* condition */} {
		${2:${VISUAL}}
	}


snippet ife "if else condition"
	if ${1:/* condition */} {
		${2:${VISUAL}}
	} else {
		${0}
	}

snippet el "else"
	else {
		${0:${VISUAL}}
	}

snippet ir "if error not nil, return err"
	if err != nil {
		return err
	}
	${0}

snippet ir "if error not nil, return fmt.Errorf"
	if err != nil {
		return fmt.Errorf("${0}: %w", err)
	}

snippet f "false"
	false

snippet ft "fallthrough"
	fallthrough

snippet fl "float"
	float32

snippet f3 "float32"
	float32

snippet f6 "float64"
	float64

snippet for "for loop"
	for ${1}{
		${0:${VISUAL}}
	}

snippet fori "for int loop"
	for ${2:i} := 0; $2 < ${1:count}; $2${3:++} {
		${0:${VISUAL}}
	}

snippet forr "for range loop"
	for ${1:e} := range ${2:collection} {
		${0:${VISUAL}}
	}

snippet fun "function"
	func ${1:funcName}(${2}) ${3:error} {
		${4}
	}
	${0}

snippet fum "method"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4}) ${5:error} {
		${6}
	}
	${0}

snippet fumh "http handler function on receiver"
	func (${1:receiver} ${2:type}) ${3:funcName}(${4:w} http.ResponseWriter, ${5:r} *http.Request) {
		${0:${VISUAL}}
	}

snippet lf "log printf"
	log.Printf("%${1:s}", ${2:var})

snippet lp "log println"
	log.Println("${1}")

snippet mk "make"
	make(${1:[]string}, ${0:0})

snippet mp "map"
	map[${1:string}]${0:int}

snippet main "func main()"
	func main() {
		${1}
	}
	${0}

snippet nw "new"
	new(${0:type})

snippet pa "package"
	package ${1:main}

snippet pn "panic"
	panic("${0:msg}")

snippet pf "fmt.Printf()"
	fmt.Printf("%${1:s}\n", ${2:var})

snippet pl "fmt.Println()"
	fmt.Println("${1:s}")

snippet rn "range"
	range ${0}

snippet rt "return"
	return ${0}

snippet rs "result"
	result

snippet sl "select"
	select {
	case ${1:v1} := <-${2:chan1}
		${3}
	default:
		${0}
	}

snippet sr "string"
	string

snippet st "struct"
	struct ${1:name} {
		${2:/* data */}
	}
	${0}

snippet sw "switch"
	switch ${1:var} {
	case ${2:value1}:
		${3}
	case ${4:value2}:
		${5}
	default:
		${0}
	}

snippet ps "fmt.Sprintf"
	fmt.Sprintf("%${1:s}", ${2:var})

snippet t "true"
	true

snippet g "goroutine named function"
	go ${1:funcName}(${0})

snippet ga "goroutine anonymous function"
	go func(${1} ${2:type}) {
		${3:/* code */}
	}(${0})

snippet test "test function"
	func Test${1:name}(t *testing.T) {
		${0:${VISUAL}}
	}

snippet testt "table test function"
	func Test${1:name}(t *testing.T) {
		tests := []struct {
			name string
		}{
			{
				name: "${2:test name}",
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				${0:${VISUAL}}
			})
		}
	}

snippet bench "benchmark function"
	func Benchmark${1:name}(b *testing.B) {
		for i := 0; i < b.N; i++ {
			${2}
		}
	}
	${0}

snippet cl "composite literals"
	type ${1:name} struct {
		${2:attrName} ${3:attrType}
	}

snippet om "if key in a map"
	if ${1:value}, ok := ${2:map}[${3:key}]; ok == true {
		${4:/* code */}
	}


snippet gg "Grouped globals with anonymous struct"
	var ${1:var} = struct{
		${2:name} ${3:type}
	}{
		$2: ${4:value},
	}


snippet ja "Marshalable json alias"
	type ${1:parentType}Alias $1

	func (p *$1) MarshalJSON() ([]byte, error) {
		return json.Marshal(&struct{ *$1Alias }{(*$1Alias)(p)})
	}


snippet errwr "Error handling with fmt.Errorf"
	if ${1}err != nil {
		return fmt.Errorf("${2} %w", err)
	}

snippet dp "print debug info"
	func (){
		// DEBUG: remove before commit
		_, file, line, _ := runtime.Caller(0)
		header := fmt.Sprintf(">>>>>> [%s:%d]", file, line)
		fmt.Println(header, ${1})
	}()

snippet jp "json Marshal and print"
	func (name string){
		// DEBUG: remove before commit
		_, file, line, _ := runtime.Caller(0)
		jb, _ := json.MarshalIndent(${1}, "", "  ")
		fmt.Printf("\n[%s:%d - %s]\n%s\n\n", file, line, name, string(jb))
		_ = ioutil.WriteFile(name + ".json", jb, 0644)
	}("${2}")

snippet jsonLoad "json load from file"
	func (){
		doc, err := ioutil.ReadFile("${1}")
		if err != nil {
			log.Fatal(err)
		}

		err = json.Unmarshal(doc, ${2})
		if err != nil {
			log.Fatal(err)
		}
	}()

snippet httpDumpRequest "dump http request"
	func(req *http.Request) {
		// DEBUG: remove before commit
		dump, err := httputil.DumpRequestOut(req, true)
		if err != nil {
			log.Fatal(err)
		}

		fmt.Printf("%s", dump)
	}(${1})

snippet httpDumpResponse "dump http response"
	func(res *http.Response) {
		// DEBUG: remove before commit
		dump, err := httputil.DumpResponse(res, true)
		if err != nil {
			log.Fatal(err)
		}

		fmt.Printf("%s", dump)
	}(${1})

snippet httpTestSvr "http test server"
	s := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if r.URL.String() == "" {
			w.WriteHeader(200)
			return
		}
		if r.URL.String() == "" {
			fmt.Fprintf(w, "{}")
			return
		}
		w.WriteHeader(404)
	}))
	defer s.Close()

snippet flags "basic flags"
	var output string
	var option converter.Option

	flag.StringVar(&output, "output", "", "the path of the output file")
	flag.IntVar(&option.MinUsers, "min-users", 0, "minimal number of participants")

	flag.Parse()

	if output == "" {
		flag.PrintDefaults()
		return
	}

snippet createFile "basic flags"
	f, err := os.Create("/tmp/dat2")
	if err != nil {
		log.Fatalf("Failed to create file: %s", err)
	}

	defer f.Close()

	d2 := []byte{115, 111, 109, 101, 10}
	_, err = f.Write(d2)
	if err != nil {
		log.Fatalf("Failed to write file: %s", err)
	}

snippet testify "import testify"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

snippet httpServer "basic http server"
	http.HandleFunc("/hello", func (w http.ResponseWriter, req *http.Request) {
		fmt.Fprintf(w, "hello\n")
	})
	http.ListenAndServe(":8090", nil)

snippet httpServerShutdown "http server with graceful shutdown"
	type apiHandler struct{}
	func (apiHandler) ServeHTTP(http.ResponseWriter, *http.Request) {}

	func main() {
		mux := http.NewServeMux()
		mux.Handle("/api/", apiHandler{})
		mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
			// The "/" pattern matches everything, so we need to check
			// that we're at the root here.
			if req.URL.Path != "/" {
				http.NotFound(w, req)
				return
			}
			w.WriteHeader(200)
			fmt.Fprintf(w, "Welcome to the home page!")
		})

		srv := &http.Server{
			Addr:    ":8080",
			Handler: mux,
		}

		done := make(chan os.Signal, 1)
		signal.Notify(done, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)

		go func() {
			if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Fatalf("listen: %s\n", err)
			}
		}()
		log.Print("Server Started")

		<-done
		log.Print("Server Stopped")

		ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
		defer func() {
			// extra handling here
			cancel()
		}()

		if err := srv.Shutdown(ctx); err != nil {
			log.Fatalf("Server Shutdown Failed:%+v", err)
		}
		log.Print("Server Exited Properly")
	}

snippet httpClient "basic http client"
	var httpClient = &http.Client{
		Timeout: time.Second * 10,
	}

	response, _ := httpClient.Get(url)

snippet httpClientTrans "basic http client"
	var netTransport = &http.Transport{
		Dial: (&net.Dialer{
			Timeout: 5 * time.Second,
		}).Dial,
		TLSHandshakeTimeout: 5 * time.Second,
	}

	var httpClient = &http.Client{
		Timeout: time.Second * 10,
		Transport: netTransport,
	}

	response, _ := httpClient.Get(url)

snippet testSkip "skip the test"
	fooAddr := os.Getenv("FOO_ADDR")
	if fooAddr == "" {
		t.Skip("set FOO_ADDR to run this test")
	}

snippet ctxDone "select ctx.Done()"
	select {
	case <-ctx.Done():
		return ctx.Err()
	case out <- v:
	default:
		// non-blocking
	}

snippet respondWithJSON "respondWithJSON"
	func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) error {
			response, err := json.Marshal(payload)
			if err != nil {
					return err
			}
			w.Header().Set("Content-Type", "application/json")
			w.Header().Set("Access-Control-Allow-Origin", "*")
			w.WriteHeader(code)
			w.Write(response)
			return nil
	}

snippet handleJSONRequest "handle JSON request"
	func handler(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			dat, err := io.ReadAll(r.Body)
			if err != nil {
					respondWithError(w, 500, "couldn't read request")
					return
			}
			params := requestBody{}
			err = json.Unmarshal(dat, &params)
			if err != nil {
					respondWithError(w, 500, "couldn't unmarshal parameters")
					return
			}
	}

snippet timeDate "create a date"
	${1:date} := time.Date(${2:year}, ${3:month}, ${4:day}, 0, 0, 0, 0, time.UTC)
	${0}

snippet timeParseRFC1123 "parse time as RFC1123"
	${1:t}, err := time.Parse("Mon, 02 Jan 2006 15:04:05 MST", ${2:str})
	${0}

snippet timeParseRFC3339 "parse time as RFC3339"
	${1:t}, err := time.Parse("2006-01-02T15:04:05Z07:00", ${2:str})
	${0}

snippet timeFormatRFC1123 "format time as RFC1123"
	${1:str} := ${2:time}.Format("Mon, 02 Jan 2006 15:04:05 MST")
	${0}

snippet timeFormatRFC3339 "format time as RFC3339"
	${1:str} := ${2:time}.Format("2006-01-02T15:04:05Z07:00")
	${0}

snippet timeZone "convert time between different timezones"
	loc, _ := time.LoadLocation("UTC")
	loc, _ = time.LoadLocation("Europe/Berlin")
	loc, _ = time.LoadLocation("America/New_York")
	${1:t} := ${2:time}.In(loc))
	${0}

snippet testTable "basic table driven tests"
	tests := map[string]struct {
		input string
		want  []string
	}{
		"simple": {input: "", want: []string{}},
	}

	for name, tc := range tests {
		t.Run(name, func(t *testing.T) {
			got := Split(tc.input, tc.sep)
		})
	}

snippet signals "handle signals"
	sigs := make(chan os.Signal, 1)
	done := make(chan bool, 1)

	signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

	go func() {
		sig := <-sigs
		fmt.Println(sig)
		done <- true
	}()

	fmt.Println("awaiting signal")
	<-done
	fmt.Println("exiting")

snippet fileExists "check if a file exists"
	if _, err := os.Stat("${1}"); err == nil {
		// path/to/whatever exists
	} else if errors.Is(err, os.ErrNotExist) {
		// path/to/whatever does *not* exist
	} else {
		// other errors
	}

snippet errst "new error struct"
	type ${1}Error struct {
		${2}
	}

	func (e *Error) Error() string {
		return ""
	}

snippet errvar "new error variable"
	var Err${1} = errors.New("${2}")

snippet erras "check errors.As"
	var e *${1}Error
	if errors.As(err, &e) {
		${2}
	}

snippet erris "check errors.Is"
	if errors.Is(err, Err${1}) {
		// err, or some error that it wraps, is a permission problem
		${2}
	}
